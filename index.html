<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Kiblat — Stabil & Kalibrasi</title>
<style>
  body{font-family:system-ui,Arial;margin:0;background:#eef6fb;min-height:100vh;display:flex;align-items:center;justify-content:center}
  .card{width:95%;max-width:540px;background:#fff;padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(7,40,60,0.08);text-align:center}
  h1{margin:0 0 6px;font-size:18px}
  #status{font-size:13px;color:#4b5d6b;margin-bottom:8px}
  #arrow{width:150px;height:150px;transition:transform 120ms linear;will-change:transform;margin:10px auto;display:block}
  #deg{font-weight:700;margin-top:6px}
  button{padding:8px 12px;border-radius:8px;border:0;background:#0b74d1;color:#fff;cursor:pointer}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:10px;flex-wrap:wrap}
  .note{font-size:13px;color:#6b7f8f;margin-top:10px}
  .debug{font-family:monospace;font-size:11px;color:#213;white-space:pre-wrap;margin-top:8px;max-height:140px;overflow:auto;border-top:1px dashed #eee;padding-top:8px}
  .cal{margin-top:8px;display:flex;gap:8px;align-items:center;justify-content:center}
  input[type=range]{width:220px}
</style>
</head>
<body>
  <div class="card">
    <h1>Penunjuk Arah Kiblat — Stabil & Kalibrasi</h1>
    <div id="status">Menunggu izin lokasi & sensor...</div>

    <svg id="arrow" viewBox="0 0 100 100" aria-hidden="true">
      <circle cx="50" cy="50" r="48" fill="rgba(11,116,209,0.04)"/>
      <g>
        <rect x="49" y="34" width="2" height="36" rx="1" fill="#d33"/>
        <polygon points="50,14 60,46 50,38 40,46" fill="#d33"/>
      </g>
    </svg>

    <div id="deg">—</div>

    <div class="controls">
      <button id="startBtn">Aktifkan Sensor Arah</button>
      <button id="calNorthBtn" class="secondary">Kalibrasi Sekarang Menghadap Utara</button>
    </div>

    <div class="cal">
      <label>Offset manual: <span id="offVal">0</span>°</label>
      <input id="offSlider" type="range" min="-90" max="90" step="1" value="0"/>
    </div>

    <div class="note">
      Jika panah masih melenceng: coba kalibrasi kompas HP (gerakan angka 8), lalu tekan
      <b>Kalibrasi Sekarang Menghadap Utara</b> sambil mengarahkan HP ke utara nyata.
    </div>

    <div id="debug" class="debug" aria-live="polite"></div>
  </div>

<script>
/* ===== konfigurasi ===== */
const kaaba = { lat: 21.422487, lon: 39.826206 };
const BUFFER_LEN = 24;        // panjang buffer untuk stabilitas kandidat
const ROT_THRESH_RAD = (0.4 * Math.PI/180); // threshold rotasi kecil ≈ 0.4° -> dianggap diam
const SMOOTH_FAST = 0.15;     // smoothing saat bergerak
const SMOOTH_SLOW = 0.02;     // smoothing saat diam (lebih kuat)
const SWITCH_HYST = 2.5;      // derajat hysteresis saat berganti kandidat
let qiblaDeg = null;
let chosenYaw = null;         // yaw terpilih (0..360)
let smoothYaw = null;         // yaw setelah smoothing/unwrapping
let manualOffset = 0;         // offset koreksi manual (deg)
let lastQuat = null;
let buffers = { A:[], B:[], C:[] };
let lastTime = null;
let screenAngleCache = 0;

/* ===== util ===== */
function norm360(a){ a = a % 360; if (a<0) a += 360; return a; }
function deg(x){ return x * 180/Math.PI; }
function rad(x){ return x * Math.PI/180; }
function shortest(oldA, target){ if (oldA==null) return target; let diff = ((target - oldA + 540) % 360) - 180; return norm360(oldA + diff); }
function ema(old, val, alpha){ if (old==null) return val; return old + alpha*( (val - old + 540)%360 - 180 ); }
function avg(arr){ if (!arr.length) return 0; return arr.reduce((s,v)=>s+v,0)/arr.length; }
function variance(arr){
  if (!arr.length) return 1e6;
  const m = avg(arr);
  return avg(arr.map(x=>{ let d = ((x-m+540)%360)-180; return d*d; }));
}

/* ===== quaternion -> rotation matrix ===== */
function quatToMatrix(q){
  // q is array [x,y,z,w] (sensor uses this ordering)
  const x=q[0], y=q[1], z=q[2], w=q[3];
  const xx=x*x, yy=y*y, zz=z*z, xy=x*y, xz=x*z, yz=y*z, wx=w*x, wy=w*y, wz=w*z;
  return [
    [1 - 2*(yy + zz),     2*(xy - wz),         2*(xz + wy)],
    [2*(xy + wz),         1 - 2*(xx + zz),     2*(yz - wx)],
    [2*(xz - wy),         2*(yz + wx),         1 - 2*(xx + yy)]
  ];
}

/* ===== hitung 3 kandidat yaw dari matriks ===== */
function computeCandidates(rot){
  // kandidat A,B,C seperti di percobaan sebelumnya
  const yawA = norm360(deg(Math.atan2(rot[1][0], rot[0][0])));         // umum
  const yawB = norm360(deg(Math.atan2(-rot[0][1], rot[1][1])));       // alternatif
  const yawC = norm360(deg(Math.atan2(rot[0][2], rot[1][2])));        // alternatif lain
  return { A: yawA, B: yawB, C: yawC };
}

/* ===== update buffer & pilih kandidat paling stabil ===== */
function pushCandidate(candidateVal){
  // push ke buffer per kandidat; simpan recent BUFFER_LEN nilai
  for (const k of ['A','B','C']){
    const v = candidateVal[k];
    const buf = buffers[k];
    buf.push(v);
    if (buf.length > BUFFER_LEN) buf.shift();
  }
  // hitung variance tiap kandidat (gunakan unwrap terhadap median)
  const varA = variance(buffers.A);
  const varB = variance(buffers.B);
  const varC = variance(buffers.C);
  // pilih index minimal variance
  let best = 'A';
  let minVar = varA;
  if (varB < minVar) { best='B'; minVar=varB; }
  if (varC < minVar) { best='C'; minVar=varC; }
  return best;
}

/* ===== screen orientation ===== */
function getScreenAngle(){
  let a = 0;
  if (screen.orientation && typeof screen.orientation.angle === 'number') a = screen.orientation.angle;
  else if (typeof window.orientation === 'number') a = window.orientation;
  return a||0;
}

/* ===== qibla calculation (spherical) ===== */
function calcQibla(lat, lon){
  const φ1 = lat * Math.PI/180;
  const φ2 = kaaba.lat * Math.PI/180;
  const Δλ = (kaaba.lon - lon) * Math.PI/180;
  const θ = Math.atan2(Math.sin(Δλ),
    Math.cos(φ1)*Math.tan(φ2) - Math.sin(φ1)*Math.cos(Δλ));
  return norm360(deg(θ));
}

/* ===== UI helpers ===== */
const arrow = document.getElementById('arrow');
const degEl = document.getElementById('deg');
const statusEl = document.getElementById('status');
const debugEl = document.getElementById('debug');
const startBtn = document.getElementById('startBtn');
const calBtn = document.getElementById('calNorthBtn');
const offSlider = document.getElementById('offSlider');
const offVal = document.getElementById('offVal');

/* update arrow rotation using smoothYaw and qiblaDeg (+ manual offset) */
function updateUI(){
  if (qiblaDeg == null || smoothYaw == null) {
    degEl.textContent = '—';
    return;
  }
  // heading = smoothYaw (0..360), adjust with manual offset
  const deviceHeading = norm360(smoothYaw + manualOffset);
  const relative = norm360(qiblaDeg - deviceHeading);
  arrow.style.transform = `rotate(${relative}deg)`;
  degEl.textContent = `Kiblat ${qiblaDeg.toFixed(2)}° • Heading ${deviceHeading.toFixed(2)}° • Rel ${relative.toFixed(2)}°`;
}

/* ===== sensor processing core ===== */
function processQuat(q, t){
  // q: quaternion [x,y,z,w], t: timestamp ms
  // compute delta rotation magnitude from lastQuat
  if (lastTime == null) lastTime = t;
  const dt = Math.max(1, t - lastTime);
  lastTime = t;

  if (lastQuat != null){
    // dot product between quaternions (absolute) for rotation angle
    const dot = Math.abs(q[0]*lastQuat[0] + q[1]*lastQuat[1] + q[2]*lastQuat[2] + q[3]*lastQuat[3]);
    // clamp dot
    const d = Math.min(1, Math.max(-1, dot));
    // angle difference (radians)
    const angleDiff = 2 * Math.acos(d);
    // if angleDiff small -> device roughly stationary
    var isStationary = angleDiff < ROT_THRESH_RAD;
  } else {
    var isStationary = true;
  }

  lastQuat = q.slice(); // copy

  // compute rotation matrix & candidates
  const rot = quatToMatrix(q);
  const cand = computeCandidates(rot);

  // push to buffers & pick stable candidate
  const bestKey = pushCandidate(cand);
  const bestYaw = buffers[bestKey].length ? avg(buffers[bestKey]) : cand[bestKey]; // use avg to smooth
  // apply screen orientation correction
  const screenAng = getScreenAngle();
  const corrected = norm360(bestYaw + screenAng);

  // smoothing: choose alpha depending on stationary or moving
  const alpha = isStationary ? SMOOTH_SLOW : SMOOTH_FAST;

  // unwrap & smooth (shortest path)
  if (smoothYaw == null) smoothYaw = corrected;
  else {
    // shortest move toward corrected, but with alpha applied
    // compute diff in (-180,180]
    let diff = ((corrected - smoothYaw + 540) % 360) - 180;
    smoothYaw = norm360(smoothYaw + diff * alpha);
  }

  chosenYaw = corrected;

  // debug info
  debugEl.textContent = [
    `best=${bestKey}  (varA=${variance(buffers.A).toFixed(2)}, varB=${variance(buffers.B).toFixed(2)}, varC=${variance(buffers.C).toFixed(2)})`,
    `isStationary=${isStationary} angleDiff=${(typeof angleDiff!=="undefined"?deg(angleDiff).toFixed(3):'n/a')}°`,
    `cand A=${cand.A.toFixed(1)} B=${cand.B.toFixed(1)} C=${cand.C.toFixed(1)}`,
    `chosenYaw(raw)=${bestYaw.toFixed(2)} corrected=${corrected.toFixed(2)} screenAng=${screenAng}`,
    `smoothYaw=${smoothYaw.toFixed(2)} manualOff=${manualOffset.toFixed(1)}`
  ].join('\n');

  updateUI();
}

/* ===== start sensor logic ===== */
async function startSensor(){
  statusEl.textContent = 'Mencoba aktifkan sensor...';
  debugEl.style.display = 'block';
  try {
    // get location once
    navigator.geolocation.getCurrentPosition(pos=>{
      qiblaDeg = calcQibla(pos.coords.latitude, pos.coords.longitude);
      statusEl.textContent = `Arah kiblat dihitung: ${qiblaDeg.toFixed(2)}° dari utara sejati`;
    }, err=>{
      statusEl.textContent = 'Gagal baca lokasi — izinkan akses lokasi.';
    }, {enableHighAccuracy:true, timeout:8000});

    // modern sensor
    if ('AbsoluteOrientationSensor' in window) {
      // Some browsers require permission via Generic Sensor API permission name "accelerometer" etc.
      // Try to start; if permission error occurs, fall back to DeviceOrientationEvent.requestPermission
      const sensor = new AbsoluteOrientationSensor({ frequency: 60, referenceFrame: 'device' });
      sensor.addEventListener('reading', () => {
        const q = sensor.quaternion; // [x,y,z,w]
        if (!q) return;
        processQuat(Array.from(q), performance.now());
      });
      sensor.addEventListener('error', ev=>{
        console.warn('Sensor error', ev.error);
        statusEl.textContent = 'Sensor error: ' + (ev.error && ev.error.name || ev.error.message || ev.error);
      });
      await sensor.start();
      statusEl.textContent = 'Sensor modern aktif ✅ (AbsoluteOrientationSensor).';
      return;
    }

    // fallback: DeviceOrientationEvent (older)
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      const res = await DeviceOrientationEvent.requestPermission();
      if (res !== 'granted') throw new Error('Izin sensor ditolak');
    }
    window.addEventListener('deviceorientation', (e) => {
      if (e.alpha == null) return;
      // fake quaternion from alpha? -> simpler fallback: use alpha as heading
      const raw = norm360(360 - e.alpha + getScreenAngle());
      // process as smoothYaw directly (simulate small rotation)
      processQuatFromAlpha(raw);
    });
    statusEl.textContent = 'DeviceOrientation (fallback) aktif.';
  } catch (err) {
    console.error(err);
    statusEl.textContent = 'Gagal aktifkan sensor: ' + (err && err.message || err);
  }
}

/* fallback simple processor when only alpha available */
function processQuatFromAlpha(rawHeading){
  // keep history to smooth & unwrap
  if (smoothYaw == null) smoothYaw = rawHeading;
  else {
    let diff = ((rawHeading - smoothYaw + 540) % 360) - 180;
    const alpha = Math.abs(diff) < 0.5 ? SMOOTH_SLOW : SMOOTH_FAST;
    smoothYaw = norm360(smoothYaw + diff * alpha);
  }
  // update debug (no quaternion)
  debugEl.textContent = `fallback alpha raw=${rawHeading.toFixed(2)} smooth=${smoothYaw.toFixed(2)}`;
  updateUI();
}

/* ===== manual calibration handlers ===== */
offSlider.addEventListener('input', (e)=>{
  manualOffset = parseFloat(e.target.value);
  offVal.textContent = manualOffset.toFixed(0);
  updateUI();
});
calBtn.addEventListener('click', ()=>{
  // assume user currently pointing device to true north — set manualOffset to align device heading to 0 relative to qibla
  if (smoothYaw == null || qiblaDeg == null) {
    alert('Tunggu hingga heading & arah kiblat tersedia, lalu coba kalibrasi lagi.');
    return;
  }
  // we want deviceHeading + manualOffset_new = measuredHeadingAligned
  // set manualOffset so current deviceHeading becomes true device heading (no change) — Instead, store offset so heading aligns to known North
  // For convenience: set offset so deviceHeading becomes what it should be relative to qibla? Simpler: set manualOffset = 0 by default, allow user to adjust slider
  manualOffset = 0;
  offSlider.value = 0;
  offVal.textContent = '0';
  alert('Mode kalibrasi: Letakkan perangkat menghadap arah Utara sejati lalu geser slider untuk koreksi. Jika Anda ingin rekam saat menghadap utara, gunakan slider untuk menyetel offset.');
});

/* ===== start button ===== */
startBtn.addEventListener('click', startSensor);

/* initial UI */
offVal.textContent = manualOffset.toFixed(0);
debugEl.textContent = 'Debug akan tampil di sini ketika sensor berjalan.';
updateUI();
</script>
</body>
</html>
